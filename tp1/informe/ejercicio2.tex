\chapter{Problema 2}

\section{Little Bishops}

Un alfil es una pieza utilizada en el juego de ajedrez el cual es jugado en una tabla con grillas cuadradas. Un alfil puede moverse solamente de forma diagonal desde su posición actual, y dos alfiles se atacan si uno de ellos está en el camino del otro. En la siguiente figura, los cuadrados negros representan los lugares alcanzables por el alfil $B_1$ desde su posición actual. La figura también muestra que los alfiles $B_1$ y $B_2$ están en posiciones de ataque, pero $B_1$ y $B_3$ no. $B_2$ y $B_3$ tampoco se atacan.

\begin{figure}[H]
\centering
\label{ej2_tableroEnunciado}
\includegraphics[scale=0.5]{./graficos/ej2/tableroEnunciado.jpg}
\end{figure}

Ahora, dados dos números \textbf{n} y \textbf{k}, su deber es determinar la cantidad de formas en que uno puede ubicar $k$ alfiles en un tablero de ajedrez de $n × n$, de forma tal que ningun par de ellos se atacan.
 
\textbf{Entrada:}

El archivo de entrada puede contener múltiples casos de test. Cada test ocupa una línea en el archivo de entrada y contiene dos enteros \textbf{n} $(1 \le n \le 8)$ y \textbf{k} $(0 \le k \le n^2)$. 

Un caso de test que contiene dos ceros para n y k finaliza la entrada y no necesitará procesar esta particular entrada.
 
\textbf{Salida:}

Para cada caso de test en la entrada imprimir una línea conteniendo el número total de formas en la cual uno puede ubicar la cantidad de alfiles dada en un tablero de ajedrez del tamaño dado tal que ningun par de ellos se atacan. Puede asumir que este número será menor a $10^{15}$.

\textbf{Url:}

\href{http://uva.onlinejudge.org/index.php?option=com\_onlinejudge\&Itemid=8\&category=10\&page=show\_problem\&problem=802}{Problema de Little Bishops}

\subsection{Solución}

Para la solución de este problema, se tuvo como idea de resolución una técnica de backtracking. La primera aproximación a la solución que surgió fue simplemente ir ubicando los alfiles uno por uno, en todas las combinaciones de posiciones (sin discriminar alfiles, es decir, la solucion en la que los alfiles $B_1$ y $B_2$ están ubicados en ciertas casillas es la misma solución con los alfiles permutados, por lo tanto solo consideramos una de ellas), podando aquellas ramas en las que dos alfiles se atacan entre sí. Si bien esta aproximación es correcta, tardaba mucho tiempo en devolver la solución.

Utilizando esta aproximación a la solución, tenemos por fin disminuír el tiempo de ejecución del algoritmo. Para esto vamos a aprovechar una propiedad que es particular de los alfiles: si un alfil está posicionado en un casillero blanco entonces es imposible que se ataque con un alfil ubicado en un casillero negro. Entonces podemos ahorrar cálculos, dividiendo el problema en dos casos:

\begin{itemize}
\item $n$ es par: en este caso la cantidad de casilleros blancos es igual a la cantidad de casilleros negros. Por lo tanto la cantidad de formas en que uno puede ubicar $k_c$ alfiles es igual tanto para los casilleros blancos como para los negros. Llamemos $f:Nat×Nat \rightarrow Nat$ a la función tal que dada una cantidad $k_c$ de alfiles disponibles para ubicar en un color, y un $n$ que se corresponde con el n de la entrada, $f(n, k_c)$ devuelve la cantidad de formas en las que se puede ubicar $k_c$ alfiles en un solo color de un tablero de $n×n$. Entonces la cantidad total de formas en las que se pueden ubicar $k$ alfiles en un tablero de ajedrez de $n×n$, con $n$ par es

\medskip
\medskip
\centerline{ $cantSoluciones(n, k) = \sum_{i = 0}^k f(n, i) * f(n, k - i)$ }
\medskip
\medskip

pues por cada forma de ubicar $i$ alfiles en un color, tenemos $f(n, k - i)$ formas de ubicar $k - i$ alfiles en el otro color.

Entonces el algoritmo calcula $f(n, i)$ para $i = 0, ..., k$ haciendo backtracking como en la primera aproximación, y realiza la sumatoria.

\item $n$ es impar: en este caso la cantidad de casilleros blancos difiere en uno con la cantidad de casilleros negros. Usamos un cálculo similar al anterior. Llamemos $f_B:Nat×Nat \rightarrow Nat$ y $f_N:Nat×Nat \rightarrow Nat$ a las funciónes tales que dado un $n$ que se corresponde con el n de la entrada y una cantidad $k_c$ de alfiles disponibles para ubicar en un color, $f_B(n, k_c)$ y $f_N(n, k_c)$ devuelven la cantidad de formas en las que se puede ubicar $k_c$ alfiles en el color blanco y en el color negro, respectivamente, ambos para un tablero de $n×n$ casilleros. Entonces la cantidad total de formas en las que se pueden ubicar $k$ alfiles en un tablero de ajedrez de $n×n$, con $n$ impar es

\medskip
\medskip
\centerline{ $cantSoluciones(n, k) = \sum_{i = 0}^k f_B(n, i) * f_N(n, k - i)$ }
\medskip
\medskip

pues por cada forma de ubicar $i$ alfiles en el color blanco, tenemos $f_N(n, k - i)$ formas de ubicar $k - i$ alfiles en el color negro.

Entonces el algoritmo calcula $f_B(n, i)$ y $f_N(n, i)$ para $i = 0, ..., k$ haciendo backtracking como en la primera aproximación, y realiza la sumatoria.
\end{itemize}

Por último, para evitar hacer cálculos, sabemos que si $k > 2 * ( n - 1 )$ entonces la cantidad de formas en las que se pueden ubicar $k$ alfiles en un tablero de $n×n$ es \textbf{0}, pues en todo tablero de $n×n$ hay $2 * ( 2 * n - 1 )$ diagonales. Cada alfil ocupa dos diagonales, por lo tanto luego de ubicar el alfil número $2 * ( n - 1 )$ no hay forma de posicionar el siguiente alfil sin que se ataque con otro. Por lo tanto en este caso el algoritmo devuelve directamente \textbf{0}.

A modo de aclaración, veamos unos ejemplos de cómo funciona el algoritmo:

Supongamos que tenemos un tablero de 2x2 y debemos ubicar 2 alfiles:

\begin{figure}[H]
\centering
\label{ej2_tablero2x2_0}
\includegraphics[scale=0.5]{./graficos/ej2/tablero2x2_0.png}\hspace{0.5in} 
\includegraphics[scale=0.5]{./graficos/ej2/alfil.png}\hspace{0.5in} 
\includegraphics[scale=0.5]{./graficos/ej2/alfil.png}\hspace{0.5in} 
\caption{Tablero de ajedrez con n = 2 y k = 2}
\end{figure}

Por supuesto no se pueden ubicar 2 alfiles en el mismo color, por lo tanto $f(2, 2) = 0$, y las formas de ubicar 0 alfiles en un color es $f(2, 0) = 1$.

Veamos que pasa con $f(2, 1)$:

\begin{figure}[H]
\centering
\label{ej2_tablero2x2_1,2}
\includegraphics[scale=0.5]{./graficos/ej2/tablero2x2_1.png}\hspace{0.5in}
\includegraphics[scale=0.5]{./graficos/ej2/tablero2x2_2.png}\hspace{0.5in} 
\caption{Ubicaciones de 1 alfil en un tablero de 2x2, para el color negro}
\end{figure}

Y como vemos en el siguiente grafico, la cantidad de formas de colocar un alfil en el color blanco es la misma que para el color negro, como explicamos antes

\begin{figure}[H]
\centering
\label{ej2_tablero2x2_3,4}
\includegraphics[scale=0.5]{./graficos/ej2/tablero2x2_3.png}\hspace{0.5in}
\includegraphics[scale=0.5]{./graficos/ej2/tablero2x2_4.png}\hspace{0.5in} 
\caption{Ubicaciones de 1 alfil en un tablero de 2x2, para el color blanco}
\end{figure}

Por lo tanto nuestro algoritmo hará el cálculo 
\medskip
\centerline{ $cantSoluciones(2, 2) = f(2, 0) * f(2, 2) + f(2, 1) * f(2, 1) + f(2, 2) * f(2, 0)$ }
\centerline{ $cantSoluciones(2, 2) = 1 * 0 + 2 * 2 + 0 * 1$ }
\centerline{ $cantSoluciones(2, 2) = 4$ }
\medskip

\subsection{Detalles de implementación}

\subsection{Cálculo de complejidad}