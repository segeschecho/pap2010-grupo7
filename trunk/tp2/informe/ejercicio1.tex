\chapter{Problema 1}

\section{1759 - Cubo}

\subsection{Enunciado}

En un futuro no muy lejano las personas buscarán juegos cada vez más peligrosos
para jugar. Después de ultra-ligeros y el bungee-jumping las personas necesitan
juegos donde sus actividades mentales también se pongan a prueba. Este es el
caso del juego llamado 'cubo', inventado en Nueva Zelanda. En algunos lugares
también es conocido por su nombre japonés: sokoban.

Considere un laberinto de dos dimensiones compuesto de casillas cuadradas, donde
cada una está libre o está ocupada por una piedra. En cada paso, puede salir de
una casilla y moverse a otra casilla vecina (es decir, arriba, abajo, izquierda y
derecha) libre. Usted está ocupando una de las casillas libres de este laberinto.

\begin{figure}[H]
\centering
\label{ej1_enunciadoSokoban}
\includegraphics[scale=0.8]{./graficos/ej1/sokoban.jpg}
\caption{Ejemplo del juego}
\end{figure}

Una casilla del laberinto contiene una pila de cajas. La pila puede ser movida 
de una casilla i a una casilla k (por ejemplo, k = i+1), vecina de i, en la
dirección ik si usted estuviera en la casilla j (aquí j = i-1), vecina de i, y
la dirección ik es igual a la dirección ji. Una caja no puede ser movida de
ninguna otra manera (es decir, no se puede tirar de la caja). Así que si la
caja termina en una esquina del laberinto no podrá moverla nuevamente.
Por último, tenga en cuenta que en cada empujón de la caja usted da un paso, y
que lo inverso no es necesariamente cierto.

Una de las casillas vacías está marcada como la casilla final. Su tarea es
llevar la caja a la casilla final a través de una serie de pasos y empujones de
la caja. Como la caja es pesada, quiere realizar el menor número posible de
empujones de la caja.

Tenga en cuenta que en el juego de la vida real existe la posibilidad de que
pueda ser aplastado por la caja, haciendo que todo mucho más divertido.

\textbf{Input:}

El archivo de entrada se compone de varias instancias. Cada instancia se inicia
con una línea que contiene dos entero r y c (ambos menores o iguales que 20) que
representando el número de filas y columnas del laberinto.

Luego se les proporcionan r líneas, cada una con c caracteres. Cada caracter
describe una casilla del laberinto. Una casilla ocupada por una piedra se indica
por \# y una casilla vacía está representada por un '.' (sin las comillas). Su
posición de partida se indica con S, la posición inicial de la caja está indicada
por B y la posición final de la caja se indica por el T.

La entrada termina cuando r = c = 0.

\textbf{Output:}

Para cada laberinto, imprima en primer lugar el número de instancia, como se
muestra en la salida de ejemplo siguiente. Si no es posible llevar el cuadro
a su posición final, escriba una línea conteniendo 'Impossivel'.
De lo contrario, deberá imprimir dos enteros x e y, donde x indica el número
de movimientos (pasos + empujones) e y el numero de empujones de una secuencia
que hace que lleve la cada hasta la posición final. El número de empujones debe
ser mínimo. Si hay más de una posible secuencia que utiliza un número mínimo de
empujes, el número total de movimientos debe ser mínimo.
Imprima una línea en blanco después de cada instancia.

\textbf{Url:}

\href{https://br.spoj.pl/problems/CUBO/}{Problema de cubo}

\subsection{Modelo}

Representamos el problema mediante un digrafo \textbf{G = (V,E)}. Un nodo $v_i \in V$ representa una posición del personaje y una posición de la caja, con $0 \leq i < r*c*(r*c - 1)$, donde \textbf{r} y \textbf{c} son los del enunciado (a priori hay $r*c$ posiciones donde puede estar la caja, y por cada posición de la caja hay $r*c - 1$ posiciones donde el personaje puede ubicarse). Un eje $e = (v_i, v_j) \in E$, con $0 \leq i < r*c*(r*c - 1)$ y $0 \leq j < r*c*(r*c - 1)$, si puedo mover al personaje desde su posición en $v_i$ hacia la posición del mismo en $v_j$, y desde la posición de la caja en $v_i$ hacia la posición de la caja en $v_j$ en un solo paso (es decir, moviendo el personaje una casilla hacia arriba, abajo, izquierda o derecha, posiblemente empujando la caja). A modo de aclaración, veamos un ejemplo:

\begin{figure}[H]
\centering
\label{ej1_modeloSokoban}
\includegraphics[scale=0.8]{./graficos/ej1/ejemploModelo.jpg}
\caption{Ejemplo de escenario}
\end{figure}

En este escenario el grafo resultante que lo representa según nuestro modelo será:

\begin{figure}[H]
\centering
\label{ej1_ejModelo}
\includegraphics[scale=0.5]{./graficos/ej1/ej1_ejModelo.png}
\caption{Grafo representativo del escenario}
\end{figure}

Para hacer el ejemplo más fácil de entender, identificamos los nodos con tuplas $<casilleroCaja, casilleroPersonaje>$. El nodo inicial es el $<5,4>$, y los nodos finales (en los que termino cuando encuentro una solución) son el $<6,3>$ y el $<6,5>$. Notemos que los ejes entre los nodos que tienen la misma primera coordenada son bidireccionales, pues el personaje puede moverse a un casillero vecino y volver al casillero de donde vino sin ninguna restricción. No es así en el caso de los ejes entre los nodos de distinta primera coordenada, pues se puede empujar una caja pero no se puede tirar de ella.

\subsection{Solución}

El problema nos pide encontrar la solución de menor cantidad de empujones, y si hay más de una solución con la mínima cantidad de empujones, devolver la solución que usa la menor cantidad de pasos del personaje. Es simple ver que la solución de la mínima cantidad de pasos se puede encontrar haciendo un BFS a partir del nodo inicial, pues en el primer nivel del árbol de BFS tendré los nodos para los cuales usé 0 pasos, en el segundo nivel los nodos de 1 paso, en el tercero 2 pasos... y seguir así hasta encontrar que un nivel contiene uno de los nodos finales. Intuitivamente este algoritmo equivale a hacer caminar al personaje hacia todas las direcciones que pueda (se puede mover hacia arriba, abajo, izquierda o derecha, dependiendo si hay o no una pared en esa dirección), empujando la caja si es necesario y posible (si el personaje quiere moverse en una dirección, y en esa dirección está la caja, y si no hay una pared detrás de la caja, en la misma dirección hacia donde quiere caminar) y repetir esto con el cuidado de no volver a un estado anterior (mismas posiciónes de la caja y del personaje que uno o varios pasos anteriores). Pero no basta con eso, pues hay soluciones de menor cantidad de empujes que requieren mayor cantidad de pasos que no estaríamos considerando y que debería ser la respuesta.

El algoritmo utilizado para la solución realiza una especie de BFS, pero cambiando el concepto de \"marcar\" los nodos que ya fueron visitados. Lo que necesitamos en su lugar es relacionar cada nodo con la mejor solución que pasa por él encontrada hasta el momento. Esto es: en cada nodo se guarda una tupla $<cantidadEmpujones, cantidadPasos>$ de forma que vuelvo a visitar (o visito por primera vez) un nodo si la cantidad de empujones que uso para llegar a él es menor que su valor de cantidadEmpujes actual, o si la cantidad de empujones que uso para llegar a él es igual que su valor de cantidadEmpujes actual y la cantidad de pasos que uso para llegar a él es menor que su valor cantidadPasos actual, es decir, vuelvo a visitarlo si mejoro la, a priori, posible solución que pasa por él que encontré anteriormente (la tupla para cada nodo sería inicializada en $<\infty,\infty>$). Esto encuentra la solución según lo pide el enunciado, pues la parte de marcar los nodos con una tupla $<cantidadEmpujones, cantidadPasos>$ me asegura que encontraré, si existe, la solución de menor cantidad de empujones, y para esta cantidad de empujones el recorrido en BFS me asegura que encontraré, si existe, la solución de menor cantidad de pasos.

Si no hay camino desde el nodo inicial hacia el nodo final quiere decir que el escenario presentado no tiene solución, por lo que el algoritmo agotará todas las posibilidades de movimiento hacia los nodos que puede llegar y eventualmente terminará, pues la cantidad de veces que el algoritmo puede mejorar la tupla $<cantidadEmpujones, cantidadPasos>$ de un nodo es acotada, ya que la cantidad de pasos y de empujones son mayores o iguales que 0 (el nodo inicial comienza con $<0,0>$ cantidad de empujones y de pasos, y no tendría sentido realizar una cantidad de empujones o de pasos negativa).

\subsection{Detalles de implementación}

El grafo del modelo no se construye previamente a la búsqueda de la solución, sino que se recorre dinámicamente, por lo que no hay ninguna estructura que lo represente directamente. Los casilleros, en lugar de ser identificados por un número, como lo explicado anteriormente, se identifican con una tupla $<i,j>$ con $1 \leq i \leq f$ y $1 \leq j \leq c$, y empiezan desde 1 pues a todo escenario le agregamos paredes alrededor.

La clase Nodo guarda un par de casilleros y una cantidad de pasos y empujones auxiliares que si bien no es necesario guardarlos aquí, lo dejamos por comodidad, ya que generalmente para un nodo me interesa saber cuantos pasos y empujones actualmente estoy haciendo (aclaración importante: esto no es lo mismo que la matriz de mejorMarca que explicaremos abajo).

Guardamos una matriz de booleanos llamada \textbf{hayPared} que dados $0 \leq i \leq f + 1$ y $0 \leq j \leq c + 1$, $hayPared[i][j]$ devuelve \textbf{true} si el casillero es una pared, y \textbf{false} en caso contrario.

Guardamos otra matriz \textbf{mejorMarca} de 4 dimensiones $filas \times columnas \times filas \times columnas$ que guarda la mejor tupla $<cantidadEmpujones, cantidadPasos>$ para cada nodo según lo explicado anteriormente.

Para realizar el BFS utilizamos un vector de la \textbf{STL} de forma que siempre hacemos $push\_back$ y nos evitamos eliminar del frente guardando un índice e incrementándolo a medida que vamos expandiéndo los nodos.

Se implementó la clase \textbf{TestCase}, que contiene el método \textbf{resolver}, que junto con el método auxiliar \textbf{adyacente}(que dado un nodo y una dirección calcula el nodo que representa el mover el personaje en esa dirección) resuelve el problema mediante el algoritmo explicado arriba.

Para optimizar, agregamos una especie de poda que verifica que solamente expando un nodo en sus adyacentes si por el camino de donde vengo es aún posible encontrar una solución de menor cantidad de empujones o de menor cantidad de pasos (si la cantidad de empujones es igual) que la mejor solución encontrada hasta el momento. Por supuesto, la cantidad de pasos y de empujones de la mejor solución hasta el momento se inicializan en $\infty$.

\subsection{Cálculo de complejidad}

Dado un nodo, se puede calcular en tiempo constante un nodo adyacente para una dirección, pues el nodo contiene una tupla de casilleros como fue descripto anteriormente y, luego se puede consultar si el resultado es un nodo inválido verificando que ninguno de los dos casilleros sean una pared (con la matriz hayPared).

Dado que el método \textbf{adyacente} y las inserciones y consultas a la cola son en tiempo constante, lo único que afecta la complejidad final del algoritmo es la cantidad de iteraciones que hace cuando va expandiendo los nodos.