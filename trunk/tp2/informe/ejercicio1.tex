\chapter{Problema 1}

\section{1759 - Cubo}

\subsection{Enunciado}

En un futuro no muy lejano las personas buscarán juegos cada vez más peligrosos
para jugar. Después de ultra-ligeros y el bungee-jumping las personas necesitan
juegos donde sus actividades mentales también se pongan a prueba. Este es el
caso del juego llamado 'cubo', inventado en Nueva Zelanda. En algunos lugares
también es conocido por su nombre japonés: sokoban.

Considere un laberinto de dos dimensiones compuesto de casillas cuadradas, donde
cada una está libre o está ocupada por una piedra. En cada paso, puede salir de
una casilla y moverse a otra casilla vecina (es decir, arriba, abajo, izquierda y
derecha) libre. Usted está ocupando una de las casillas libres de este laberinto.

\begin{figure}[H]
\centering
\label{ej1_enunciadoSokoban}
\includegraphics[scale=0.8]{./graficos/ej1/sokoban.jpg}
\caption{Ejemplo del juego}
\end{figure}

Una casilla del laberinto contiene una pila de cajas. La pila puede ser movida 
de una casilla i a una casilla k (por ejemplo, k = i+1), vecina de i, en la
dirección ik si usted estuviera en la casilla j (aquí j = i-1), vecina de i, y
la dirección ik es igual a la dirección ji. Una caja no puede ser movida de
ninguna otra manera (es decir, no se puede tirar de la caja). Así que si la
caja termina en una esquina del laberinto no podrá moverla nuevamente.
Por último, tenga en cuenta que en cada empujón de la caja usted da un paso, y
que lo inverso no es necesariamente cierto.

Una de las casillas vacías está marcada como la casilla final. Su tarea es
llevar la caja a la casilla final a través de una serie de pasos y empujones de
la caja. Como la caja es pesada, quiere realizar el menor número posible de
empujones de la caja.

Tenga en cuenta que en el juego de la vida real existe la posibilidad de que
pueda ser aplastado por la caja, haciendo que todo mucho más divertido.

\textbf{Input:}

El archivo de entrada se compone de varias instancias. Cada instancia se inicia
con una línea que contiene dos entero r y c (ambos menores o iguales que 20) que
representando el número de filas y columnas del laberinto.

Luego se les proporcionan r líneas, cada una con c caracteres. Cada caracter
describe una casilla del laberinto. Una casilla ocupada por una piedra se indica
por \# y una casilla vacía está representada por un '.' (sin las comillas). Su
posición de partida se indica con S, la posición inicial de la caja está indicada
por B y la posición final de la caja se indica por el T.

La entrada termina cuando r = c = 0.

\textbf{Output:}

Para cada laberinto, imprima en primer lugar el número de instancia, como se
muestra en la salida de ejemplo siguiente. Si no es posible llevar el cuadro
a su posición final, escriba una línea conteniendo 'Impossivel'.
De lo contrario, deberá imprimir dos enteros x e y, donde x indica el número
de movimientos (pasos + empujones) e y el numero de empujones de una secuencia
que hace que lleve la cada hasta la posición final. El número de empujones debe
ser mínimo. Si hay más de una posible secuencia que utiliza un número mínimo de
empujes, el número total de movimientos debe ser mínimo.
Imprima una línea en blanco después de cada instancia.

\textbf{Url:}

\href{https://br.spoj.pl/problems/CUBO/}{Problema de cubo}

\subsection{Modelo}

Representamos el problema mediante un digrafo \textbf{G = (V,E)}. Un nodo $v_i \in V$ representa una posición del personaje y una posición de la caja, con $0 \leq i < r*c*(r*c - 1)$, donde \textbf{r} y \textbf{c} son los del enunciado (a priori hay $r*c$ posiciones donde puede estar la caja, y por cada posición de la caja hay $r*c - 1$ posiciones donde el personaje puede ubicarse). Un eje $e = (v_i, v_j, w) \in E$, con $0 \leq i < r*c*(r*c - 1)$ y $0 \leq j < r*c*(r*c - 1)$, si puedo mover al personaje desde su posición en $v_i$ hacia la posición del mismo en $v_j$, y desde la posición de la caja en $v_i$ hacia la posición de la caja en $v_j$ en un solo paso del personaje (es decir, moviendo el personaje una casilla hacia arriba, abajo, izquierda o derecha, posiblemente empujando la caja). Si para el mismo eje la posición de la caja en $v_i$ es distinta de la posición de la caja en $v_j$ entonces $w = 1$, y en caso contrario $w = 0$, es decir, un eje implica un paso del personaje, pero no necesariamente un empujón a la caja. El modelo no contiene nodos que impliquen que la caja o el personaje estan en la misma posición o en la posición donde hay una piedra. A modo de aclaración, veamos un ejemplo:

\begin{figure}[H]
\centering
\label{ej1_modeloSokoban}
\includegraphics[scale=0.8]{./graficos/ej1/ejemploModelo.jpg}
\caption{Ejemplo de escenario}
\end{figure}

En este escenario el grafo resultante que lo representa según nuestro modelo será:

\begin{figure}[H]
\centering
\label{ej1_ejModelo}
\includegraphics[scale=0.5]{./graficos/ej1/ej1_ejModelo.png}
\caption{Grafo representativo del escenario}
\end{figure}

Para hacer el ejemplo más fácil de entender, identificamos los nodos con tuplas $<casilleroCaja, casilleroPersonaje>$. Numeramos los casilleros de $1$ a $f*c$, ignorando la pared, de izquierda a derecha y de arriba a abajo. El nodo inicial es el $<5,4>$ que remarcamos, o sea, la caja en el casillero 5 y el personaje en el 4. Notemos que los ejes entre los nodos que tienen la misma primera coordenada son bidireccionales, pues el personaje puede moverse a un casillero vecino y volver al casillero de donde vino sin ninguna restricción, y le corresponde el peso 0. No es así en el caso de los ejes entre los nodos de distinta primera coordenada, pues se puede empujar una caja pero no se puede tirar de ella, y les corresponde peso 1.

\subsection{Solución}

El problema nos pide encontrar la solución de menor cantidad de empujones, y si hay más de una solución con la mínima cantidad de empujones, devolver la solución que usa la menor cantidad de pasos del personaje. Dado el modelo, esto nos convierte el problema en uno de encontrar un camino mínimo $C$ del tipo: $<v_0, v_1, ..., v_n>$, donde $v_0$ es el nodo inicial \textbf{S} y $v_n$ es un nodo $<goal, x>$, goal es la posición \textbf{T} del enunciado y x es cualquier posición válida, y no existe ningún nodo $v_i \in C$ del tipo $<goal, y>$, con $i \neq n$, x posición válida y $x \neq y$. Es decir, el camino pasando por la mínima cantidad de nodos y de menor peso que termina al encontrar el primer nodo en el que la caja está en su posición final. Que el camino sea de peso mínimo nos asegura que la solución es la de menor cantidad de empujones, y que pase por la mínima cantidad de nodos y termine en el primer nodo tal que la posición de la caja es la final nos asegura que es una solución y es la de mínima cantidad de pasos.

Encontrar el camino mínimo entre dos nodos se puede hacer con Dijkstra, pero por motivos de performance y gracias al modelo, optamos por realizar un BFS. Sea $dist_v$ la distancia calculada por BFS en el grafo G desde el vértice inicial $v_0$ hasta el vértice $v$, se cumple que si $(u, v) \in E$ entonces $| dist_u - dist_v| \leq 1$, pues todos los ejes son de peso 0 o 1. Podemos realizar entonces el BFS para camino mínimo según como fue planteado en clase, respetando el invariante, desde el nodo inicial \textbf{S} dado por el enunciado. El árbol de BFS nos dará el camino mínimo desde el nodo \textbf{S} hacia todos los demás nodos de la misma componente conexa, por lo que si inicializamos la distancia al nodo inicial en 0 y la distancia a todos los demas en $\infty$, si no existe el camino entre el nodo inicial y el nodo final el BFS recorrerá todos los nodos alcanzables desde el vértice inicial y finalizará, dejándonos la distancia al nodo final en $\infty$, lo que significa que debemos devolver como resultado ''Impossivel''. Si existe camino, entonces BFS nos devuelve el mínimo, donde su largo es la cantidad de pasos hechos por el personaje, y la distancia al nodo final (la suma de los pesos de sus ejes calculado por BFS) es la cantidad de empujones a la caja.

\subsection{Detalles de implementación}

El grafo del modelo no se construye previamente a la búsqueda de la solución, sino que se recorre dinámicamente, por lo que no hay ninguna estructura que lo represente directamente. Los casilleros, en lugar de ser identificados por un número, como lo explicado anteriormente, se identifican con una tupla $<i,j>$ con $1 \leq i \leq f$ y $1 \leq j \leq c$, y empiezan desde 1 pues a todo escenario le agregamos paredes alrededor (el input puede venir sin paredes, y se nos hacía más simple agregarle las paredes alrededor para verificar si el personaje se puede mover hacia una dirección).

Se implementó una clase Nodo que guarda un par de casilleros.

Utilizamos una matriz de booleanos llamada \textbf{mHayPared} que dados $0 \leq i \leq f + 1$ y $0 \leq j \leq c + 1$, $hayPared[i][j]$ devuelve \textbf{true} si el casillero es una pared, y \textbf{false} en caso contrario.

Para cada camino acumulamos la cantidad de pasos hechos y la cantidad de empujones. La cantidad de pasos es la cantidad de nodos visitados para ese camino, pues tratándose de un BFS los nodos no se visitan más de una vez. Para eso utilizamos otra matriz \textbf{mMinDist} de 4 dimensiones $filas \times columnas \times filas \times columnas$ que es auxiliar para el BFS y durante su ejecución guarda la mejor tupla $<cantidadPasos, cantidadEmpujones>$. Una tupla $<cantidadPasos1, cantidadEmpujones1>$ es mejor que otra tupla $<cantidadPasos2, cantidadEmpujones2>$ si $cantidadEmpujones1 < cantidadEmpujones2$ o si $cantidadEmpujones1 = cantidadEmpujones2$ y $cantidadPasos1 < cantidadPasos2$.

Para realizar el BFS utilizamos dos vectores de la \textbf{STL}, uno para los nodos a los que llegué por un eje de peso 0, y otro para los nodos a los cuales llegué por un eje de peso 1, de forma que siempre hacemos $push\_back$ y nos evitamos eliminar del frente guardando un índice e incrementándolo a medida que vamos expandiéndo los nodos.

Se implementó la clase \textbf{TestCase}, que contiene el método \textbf{resolver}, que junto con el método auxiliar \textbf{adyacente}(que dado un nodo y una dirección calcula el nodo que representa el mover el personaje en esa dirección) resuelve el problema mediante el algoritmo explicado anteriormente.

\subsection{Cálculo de complejidad}

La complejidad del BFS para caminos mínimos es $O(n + m)$ según lo dado en clase, donde m se puede acotar por $4n$ (cada nodo puede tener a lo sumo 4 ejes de salida, correspondientes a las 4 direcciones de movimiento) y n es $(r*c)^2$, por lo que nuestro algoritmo resulta ser de complejidad $O((r*c)^2)$.